# PLT: TERMS


Abstract
Abstract Classes and Interfaces
Abstract Example
Abstract Members
Access Level Guideline
Access Levels
Accessing Object Members
Accessing Static Members
Anonymous Methods
Array Access
Array Allocation
Array Assignment
Array Declaration
Arrays
Assemblies
Assignment
Async return types
Asynchronous methods
Attributes
Auto-Implemented Properties
Base Keyword
Binary Operator Overloading
Bool type
Boxing
Caller Information
Calling Generic Methods
Calling Methods
Catch Block
Char type
Class
Class Interface
Classes
Collections
Comments
Concepts
Conditionals
Constant fields
Constant Guideline
Constants
Constraints
Constructor
Constructor Chaining
Constructor Overloading
Custom async methods
Custom Conversions
Declaration
Default Constructor
Default Values
Definition
Defining Methods
Delegate Signature
Delegates
Delegates as Parameters
Destructor
Downcast
Enum
Enum Constant Type
Enum Access Levels
Enum Scope
Enum Constant Values
Enum Example
Enum Methods
Escape Characters
Event Caller
Event Handler
Event Keyword
Events
Exception Filters
Exception Handling
Explicit Conversion Methods
Expression Body Members
Expression Trees
Extended return types
Extension Methods
Finally Block
Floating-point types
Functionality Interface
Garbage Collector
Generic Class Inheritance
Generic Classes
Generic Delegates
Generic Events
Generic Interfaces
Generic Methods
Generic Type Parameters
Default Value
Generics
Generics and Object
Overriding Members
Hiding Members
Implicit Conversion Methods
In Parameters
Indexer Overloading
Indexer Parameters
Indexers
Inheritance
Initial Field Values
Inner Classes
Integral types
Interface Example
Interface Signatures
Interfaces
Internal Access
Iterators
Jagged Arrays
Keywords
Lambda Expressions
Local Constants
Local Methods
Loops
Method Overloading
Method Parameters
Methods
Multicast Delegates
Multiple Constraints
Named Arguments
Namespace
Namespace Access
Nested Namespaces
Null Keyword
Null-Coalescing Operator
Null-Conditional Operator
Nullable Types
Object class
Object Creation
Object Initializers
Operator Overloading
Operator Overloading Example
Operators
Optional Parameters
Out Keyword
Overloadable Operators
Overriding Members
Params Keyword
Partial Class
Pass by Reference
Pass by Value
Pattern matching
Preprocessor
Private Access
Private Protected Access
Properties
Property Access Levels
Property Advantages
Protected Access
Protected Internal Access
Public Access
Publisher
Raising Events
Read-Only and Write-Only Properties
Readonly
Rectangular Arrays
Redefining members
Ref Keyword
Reflection
Return Statement
Return Types and Parameters
Sealed Keyword
Serialization
Simple types
Static
Static Classes
Static Constructor
Static Fields
Static Methods
String Comparison
String Concatenation
String Members
StringBuilder Class
Strings
Struct
Struct Constructors
Struct Field Initializers
Struct Guideline
Struct Inheritance
Struct Variable
Subscriber
Subscribing to Events
Syntax
The async and await keywords
The is and as keywords
The using Statement
This Keyword
Throwing Exceptions
Top-Level Access Levels
True and False Operator Overloading
Try-Catch Statement
Unary Operator Overloading
Unboxing
Upcast
Using Directive
Value and Reference Types
Variable scope
Variable type
Variables
Variance
Constraints


abortive exit
abstract data type
abstract function
abstraction
abstraction
activation record
active block
ad hoc generic
ad hoc polymorphic domain
Ada derived type
Ada generic
additional binding
ADT
alias
allocation process
ambiguity
application
arity
array bounds
array dimension
ASCII
assertion, Prolog
assignment
atom, Prolog
automatic conversion
axioms
backtrack, Prolog
bad restriction
base type of a pointer
base type of a set
base type of an array
BCD
beta redex
beta reducible expression
binary operator
binding a name
binding at source time
binding time
birth of name
birth of object
bitwise operators
block exit time
block structure
block
block
BNF
bound variable
business computer
call-by-address
call-by-constant
call-by-name order
call-by-name
call-by-need
call-by-pointer
call-by-return
call-by-value-and-return
call/cc
call-with-current-continuation
captured reference
checkpoint
class member
clausal logic
closure
closure
coherent assignment
coherent representation
604INDEX
coherent representation
combinatorial explosion
compiler bug
complete name
complete system
complete
comprehension
computation tree
computer representation
conclusion
concrete type
conditional expression
conditional sentence
conditional statement
conformant arrays
conservative conversion
constructor
contents of an object
context free languages
continuation
control diagram
control frame
control frame
control structure
counted loop
curry a function
currying
cut operation, for resolution
cut, Prolog
dangling reference
data hiding
data type
deallocation
death of an object
death of name
death of object
decidable
declaration
deduction
defaults
defining occurrence
demotion cast
demotion
denotational semantics
denotes
dereference
destructive assignment
dictionary
diffuse representation
dispatch a call
dispatch
dispatcher
dispatcher
distinguishable domains
domain checking
domain mapping
domain
dual type
dyadic operator
dynamic binding
dynamic binding
dynamic link
dynamic link
dynamic parent
dynamic scope
dynamic scoping
dynamic storage
EBCDIC
encapsulate
encoding conversion
encoding conversion
enumerated type
environment
error propagation
evaluation, inside-out
evaluation, outside-in
exception handler
exception
expansion of a non-terminal
explicit representation
expressive language
extension 107606 INDEX
extension
extent of an object
external domain
external object
external scope
first class object
first class objects
first-order predicate calculus
fixed point number
fixed point
fixed point
flexible language
flexible language
formal language
free union
free variable
freelist
front end processor
function domain
function method
function range
functional composition
functional language
functional language
functional
functor
garbage collection
garbage collector
garbage
garbage
general loop
generate a program
generator
generic domain
generic domain
generic function
generic function
generic object
generic package
generic package
generic packages
global scope
goal
good restriction
guarded expression
heap allocation
heap storage
hidden data
higher-order function
higher-order function
Horn clause
hyperresolution
identifier
immortal object
implicit representation
independent domains
indeterminate result
index type
indirectly bound
infinite list
information-losing conversion
inherit
inheritance
inheritance
inherited function
inherited
initialization
in-line code
instance of a generic domain
instantiate a package
instantiate, in C++
instantiate
instantiate
instantiated type
instantiation
internal domain
internally merged domains
invisible name
IROV
iteration element
labeled scope
lambda calculus formulas 97INDEX
lambda calculus variable
lambda evaluation
lambda expression body
lambda expression parameter
lambda expression
lambda function call syntax
lambda reduction rule
lambda substitution
language extension
lazy evaluation
lazy evaluation
lex
lexer generator
lexer
lexical analysis
lexical ancestor
lexical delimiter
lexical parent
lexical scoping
lexical token
lifetime of object
LISP atom
LISP lambda expression
list comprehension
list specification
list
local scope
logic language
logical consequence
logical operators
loop variable
makefile
masked definition
meaning of a name
meaning of a program
meaning of an object
meaning of code
meaning of expression
memory fragmentation
memory management
message
metalanguage
method
method
mode graph
mode
modularity
module
monadic operator
multiple assignment
multiply bound name
name binding
name conflict
name refers to
naming conflict
N-ary
necessary control structures
nested lifetimes
nonstandardized language
normal exit
normal form
normal form
normal form
normal function call-syntax
normal order
N-step proof
nuance
object
object-oriented language
object-oriented language
one-in/one-out
opaque derived mode
open list
operands
overloaded name
parallel arrays
parallel evaluation
parallel language
parameter mode
parameterized generic domain
parameterized domain
parameterized module 531608 INDEX
parameterized type expression
parse tree
parse tree
parse tree
parser generator
parser
partial parameterization
p-code
pointer assignment
pointer variable
polymorphic object
polymorphic type
polymorphic type
portable code
portable program
postfix order
powerful language
predicate
prefix order
prefix syntax
premise
priming read
primitive control
primitive
private symbol
procedural language
process
program object
promises
promotion cast
promotion
proof system
proof
proposition
public symbol
pure functional language
pure value
qualifier list
rank of an array
recurrence equation
redex
reduction
reference constructor
reference conversion
reference
refutation
relatively global scope
representation of an object
represented by
resolution deduction
resolution proof
resolution
resolution
rule, Prolog
run-time dispatcher
run-time stack
satisfy
scientific computer
scope of a name
scope of quantifier
scope
scope-resolution operator
selection function
semantic basis
semantic basis
semantic intent
semantic intent
semantic rules
semantic validity
semiindependent domains
sentence
short circuit evaluation
simple object
size conversion
size conversion
size
slice of an array
spaghetti code
species of a generic domain
specific domain
specific type
specification 338INDEX
stack frame
static binding
static binding
static link
static link
static storage
storage compaction
storage object
stream
strict evaluation
strict evaluation
strict evaluation
strongly typed language
strongly typed language
structure of a program
structured editor
structured programming
subdomain
subroutine call
subroutine return
superdomain
symbol table
syntactic analysis
syntactic category
syntactic sugar
syntax
tail recursion
term
terminated string
theorem
theory
tripcount
tuple
type cast
type cast
type checking
type coercion
type coercion
type compatible
type constructor
type conversion
type conversion
type declaration
type description
type error
type match
type name
type of a type
type predicate
type predicate
type tag
type
type-object
unary operator
unbound name
unbound symbol
undefined name
undefined value
undefined value
unification
union types
unit record equipment
universe of discourse
unlabeled scope
Until test
upward compatibility
use of an identifier
use of parameter
valid representation
valid sentence
value constructor
value of an object
VAR parameter passing
variable declaration
variable
virtual class
virtual function
visibility
visible name
While test
word alignment
zero-based subscripting
ZF expression
